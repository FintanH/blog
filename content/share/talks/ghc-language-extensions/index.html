<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Andrew McMiddlin">
  <meta name="dcterms.date" content="2019-05-15">
  <title>GHC Language Extensions</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
<link rel="stylesheet" href="css/monokai-sublime.css" />
<link rel="stylesheet" href="css/tweaks.css">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div id="grid-setup"></div>
  <div class="reveal">
    <div class="slides">

<section>
  <h1 class="title">GHC Language Extensions</h1>
  <p class="author">Andrew McMiddlin</p>
  <p class="date">2019-05-15</p>
<img src="images/CSIRO-Data61-reversed-green-hex.svg" alt="data61 logo" style="height: 200px; background-color: inherit; margin-top: 25px;">
</section>

<section id="section" class="title-slide slide level1"><h1></h1><pre class="no-highlight"><code data-trim data-noescape>
type-class-extensions.lhs:3:3: error:
    • Too many parameters for class ‘Foo’
      <span class="fragment highlight-current-green">(Enable MultiParamTypeClasses to allow multi-parameter classes)</span>
    • In the class declaration for ‘Foo’
  |
3 | > class Foo a b where
  |   ^^^^^^^^^^^^^^^^^^^...
</code></pre>
<aside class="notes">
<ul>
<li>Raise hands if you’ve seen an error like this before?</li>
<li>Keep them up if you’ve enabled the extension without knowing why you needed it.</li>
<li>I’m guilty too — thought it was time to look at them in more detail.</li>
</ul>
</aside>
<!-- ## -->
<!-- ```haskell -->
<!-- {-# LANGUAGE ConstraintKinds       #-} -->
<!-- {-# LANGUAGE DataKinds             #-} -->
<!-- {-# LANGUAGE DeriveDataTypeable    #-} -->
<!-- {-# LANGUAGE DeriveGeneric         #-} -->
<!-- {-# LANGUAGE FlexibleInstances     #-} -->
<!-- {-# LANGUAGE MultiParamTypeClasses #-} -->
<!-- {-# LANGUAGE OverloadedStrings     #-} -->
<!-- {-# LANGUAGE PolyKinds             #-} -->
<!-- {-# LANGUAGE ScopedTypeVariables   #-} -->
<!-- {-# LANGUAGE TupleSections         #-} -->
<!-- {-# LANGUAGE TypeFamilies          #-} -->
<!-- {-# LANGUAGE TypeOperators         #-} -->
<!-- {-# LANGUAGE UndecidableInstances  #-} -->
<!-- ``` -->
<!-- ::: notes -->
<!--  - Taken from `servant` --- `Servant.API.ContentTypes` -->
<!-- ::: --></section>
<section><section id="language-extensions-101" class="title-slide slide level1" data-background="images/extensions.png"><h1>Language extensions 101</h1></section><section id="haskell-2010" class="slide level2">
<h2>Haskell 2010</h2>
<div class="left">
<p>Haskell 2010 is defined in the <a href="https://www.haskell.org/onlinereport/haskell2010/haskell.html">Haskell 2010 Language Report</a>.</p>
</div>
<aside class="notes">
<p>There are multiple versions of the Haskell programming language.</p>
<p>Most people are probably using Haskell 2010.</p>
</aside>
</section><section id="whats-not-in-haskell-2010" class="slide level2">
<h2>What’s not in Haskell 2010?</h2>
<div class="left">
<ul>
<li class="fragment">Type classes with more than one parameter.</li>
<li class="fragment">String literals for anything other than <code>[Char]</code></li>
<li class="fragment">Generalised Algebraic Data Types (GADTs)</li>
</ul>
</div>
<aside class="notes">
<p>Might think of these as standard.</p>
</aside>
</section><section id="language-extensions" class="slide level2">
<h2>Language extensions</h2>
<div class="left fragment">
<p><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-19100012.3">Section 12.3</a> covers the <code>LANGUAGE</code> pragma, which is used for extensions.</p>
</div>
</section><section id="enabling-extensions-in-ghc" class="slide level2">
<h2>Enabling extensions in GHC</h2>
</section><section id="section-1" class="slide level2">
<h2></h2>
<pre class="haskell"><code>{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE GADTs, ScopedTypeVariables #-}</code></pre>
</section><section id="section-2" class="slide level2">
<h2></h2>
<pre class="no-highlight"><code>default-extensions:    OverloadedStrings
                     , GADTs
                     , ScopedTypeVariables</code></pre>
</section><section id="section-3" class="slide level2">
<h2></h2>
<pre class="no-highlight"><code>ghc -XOverloadedStrings Foo.hs</code></pre>
</section><section id="section-4" class="slide level2">
<h2></h2>
<pre class="no-highlight"><code>$ ghci
λ :set -XOverloadedStrings</code></pre>
</section></section>
<section><section id="sugar" class="title-slide slide level1" data-background="images/sugar-coloured-wedges-dark.jpg"><h1>Sugar</h1></section><section id="overloadedstrings" class="slide level2">
<h2><code>OverloadedStrings</code></h2>
<div class="left">
<p>Enable overloaded string literals.</p>
</div>
</section><section id="section-5" class="slide level2">
<h2></h2>
<pre class="no-highlight"><code data-trim data-noescape>
GHCi, version 8.6.4: http://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/andrew/git/dot-files/.ghci
λ> :t "Lambda"
"Lambda" :: [Char]
<span class="fragment">λ> :set -XOverloadedStrings 
λ> :t "Jam"
"Jam" :: Data.String.IsString p => p</span>
</code></pre>
</section><section id="section-6" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
class IsString a where
  fromString :: String -> a
<div class="fragment fade-in-then-semi-out">
instance IsString Text where
  fromString = pack
</div>
<span class="fragment fade-in-then-semi-out">isGood :: Text -> Bool</span>

<span class="fragment fade-in-then-semi-out">isGood "foo"</span>
</code></pre>
</section><section id="tuplesections" class="slide level2">
<h2><code>TupleSections</code></h2>
<div class="left">
<p>Allow partially applied tuple constructors.</p>
</div>
</section><section id="section-7" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
<span class="fragment fade-semi-out" data-fragment-index="1">\x -> x * 2</span>

<span class="fragment fade-in-then-semi-out" data-fragment-index="1">(* 2)</span>

<span class="fragment fade-in-then-semi-out" data-fragment-index="2">\x -> (x,True)</span>

<span class="fragment fade-in-then-semi-out" data-fragment-index="3">(,True)</span>
</code></pre>
</section><section id="section-8" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
(,True,,,"hi",)<span class="fragment fade-in"> :: a -> b -> c -> d -> (a,Bool,b,c,String,d)</span>
</code></pre>
</section><section id="instancesigs" class="slide level2">
<h2><code>InstanceSigs</code></h2>
<div class="left">
<p>Allow type signatures for definitions of instance members.</p>
</div>
</section><section id="section-9" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
instance (Traversable f, Traversable g) => Traversable (Compose f g)
  <span class="fragment">traverse :: (a -> h b) -> Compose f g a -> h (Compose f g b)</span>
  traverse = undefined
</code></pre>
</section><section id="section-10" class="slide level2">
<h2></h2>
<pre class="no-highlight"><code data-trim data-noescape>
    • Illegal type signature in instance declaration:
        traverse' :: (a -> h b) -> Compose f g a -> h (Compose f g b)
      (Use InstanceSigs to allow this)
    • In the instance declaration for ‘Traversable' (Compose f g)’
   |
25 |   traverse' :: (a -> h b) -> Compose f g a -> h (Compose f g b)
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</code></pre>
</section><section id="lambdacase" class="slide level2">
<h2><code>LambdaCase</code></h2>
<div class="left">
<p>Adds syntactic sugar for pattern matching on a function’s argument.</p>
</div>
</section><section id="section-11" class="slide level2">
<h2></h2>
<pre class="haskell"><code>pretty ::
  -&gt; Expr
  -&gt; Text
pretty e = case e of
  LitI n -&gt; pack $ show n
  LitB True -&gt; &quot;true&quot;
  LitB False -&gt; &quot;false&quot;</code></pre>
</section><section id="section-12" class="slide level2">
<h2></h2>
<pre class="haskell"><code>pretty ::
  -&gt; Expr
  -&gt; Text
pretty = \case
  LitI n -&gt; pack $ show n
  LitB True -&gt; &quot;true&quot;
  LitB False -&gt; &quot;false&quot;</code></pre>
</section><section id="multiwayif" class="slide level2">
<h2><code>MultiWayIf</code></h2>
<div class="left">
<p>Adds syntactic sugar for nested <code>if-then-else</code> expressions.</p>
</div>
</section><section id="section-13" class="slide level2">
<h2></h2>
<pre class="haskell"><code>  if 1 &lt; 0 then
    &quot;foo&quot;
  else if 12 &gt; 4 then
    &quot;bar&quot;
  else if even 42 then
    &quot;42&quot;
  else
    &quot;no idea&quot;</code></pre>
</section><section id="section-14" class="slide level2">
<h2></h2>
<pre class="haskell"><code>  if | 1 &lt; 0 -&gt; &quot;foo&quot;
     | 12 &gt; 4 -&gt; &quot;bar&quot;
     | even 42 -&gt; &quot;42&quot;
     | otherwise -&gt; &quot;no idea&quot;</code></pre>
</section></section>
<section><section id="records" class="title-slide slide level1" data-background="images/records.jpg"><h1>Records</h1></section><section id="recordwildcards" class="slide level2">
<h2><code>RecordWildCards</code></h2>
<div class="left">
<p>Elide fields from record construction and pattern matching.</p>
</div>
</section><section id="section-15" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
<span class="fragment" data-fragment-index="3"><mark>{-# LANGUAGE RecordWildCards #-}</mark></span>

data Person =
  Person {
    firstName :: Text
  , surname   :: Text
  , height    :: Integer
  }

<span class="fragment fade-in-then-semi-out" data-fragment-index="1">greetPerson ::
  Person
  -> Text
greetPerson </span><span class="fragment" data-fragment-index="1"><span class="fragment highlight-red" data-fragment-index="2"><span class="fragment fade-out no-layout" data-fragment-index="4">Person{firstName = firstName, surname = surname, height = height}</span></span></span><span class="fragment no-layout" style="color: red" data-fragment-index="4">Person{..}</span><span class="fragment fade-in-then-semi-out" data-fragment-index="1"> =
  undefined</span>
</code></pre>
</section><section id="section-16" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
{-# LANGUAGE RecordWildCards   #-}

defaultPerson ::
  Person
defaultPerson =
  let
    firstName = "Andrew"
    surname = "McMiddlin"
    height = 185
  in
    Person {..}
</code></pre>
</section><section id="section-17" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE RecordWildCards   #-}

<span class="fragment fade-in-then-semi-out" data-fragment-index="1">data ConferenceAttendee =
  ConferenceAttendee {
    firstName :: Text
  , surname   :: Text
  , height    :: Integer
  , shirtSize :: ShirtSize
  }</span>

<span class="fragment fade-in-then-semi-out" data-fragment-index="2">defaultConferenceAttendee ::
  Person
  -> ConferenceAttendee
defaultConferenceAttendee</span> <span class="fragment" data-fragment-index="3">Person{..}</span> <span class="fragment fade-in-then-semi-out" data-fragment-index="2">=</span>
  <span class="fragment" data-fragment-index="4">ConferenceAttendee {shirtSize = M, ..}</span>
</code></pre>
</section><section id="section-18" class="slide level2">
<h2></h2>
<div class="left">
<p>Some problems with <code>RecordWildCards</code></p>
<ul>
<li class="fragment">Unclear where variables come from.</li>
<li class="fragment">All fields are brought into scope.</li>
<li class="fragment">Vulnerable to changes in the record.</li>
</ul>
</div>
<aside class="notes">
<ul>
<li>Especially if record definition not in your code base.</li>
<li>Best to avoid unless you want all fields.</li>
<li>Added fields are brought into scope — get a warning if shadowing at least.</li>
</ul>
</aside>
</section><section id="namedfieldpuns" class="slide level2">
<h2><code>NamedFieldPuns</code></h2>
<div class="left">
<p>Remove some of the boilerplate when bringing record fields into scope.</p>
</div>
</section><section id="section-19" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
{-# LANGUAGE NamedFieldPuns #-}

greetPerson ::
  Person
  -> Text
greetPerson <span class="fragment">Person{firstName, surname, height}</span> =
  undefined
</code></pre>
</section><section id="section-20" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
{-# LANGUAGE NamedFieldPuns #-}

greetPerson ::
  Person
  -> Text
greetPerson Person{firstName, surname} =
  undefined
</code></pre>
</section></section>
<section><section id="heavyweight" class="title-slide slide level1" data-background="images/muhammad-ali.jpg"><h1>Heavyweight</h1></section><section id="scopedtypevariables" class="slide level2">
<h2><code>ScopedTypeVariables</code></h2>
<div class="left">
<p>Scope type variables to the lexical scope of the expression.</p>
</div>
</section><section id="section-21" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
f ::
  [a] -> [a]
<span class="fragment fade-semi-out" data-fragment-index="1">f xs =
  ys ++ ys
  where</span>
    ys :: [a]
    <span class="fragment fade-semi-out" data-fragment-index="1">ys = reverse xs</span>
</code></pre>
</section><section id="section-22" class="slide level2">
<h2></h2>
<pre><code class="nohighlight" data-trim data-noescape>
<span class="fragment fade-semi-out" data-fragment-index="1">Couldn't match type ‘a’ with ‘a1’
‘a’ is a rigid type variable bound by
  the type signature for:</span>
    f :: forall a. [a] -> [a]
  <span class="fragment fade-semi-out" data-fragment-index="1">at examples/ScopedTypeVariables.hs:(5,1)-(6,12)
‘a1’ is a rigid type variable bound by
  the type signature for:</span>
    ys :: forall a1. [a1]
  <span class="fragment fade-semi-out" data-fragment-index="1">at examples/ScopedTypeVariables.hs:10:5-13
Expected type: [a1]
  Actual type: [a]</span>
</code></pre>
</section><section id="section-23" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
<span class="fragment">{-# LANGUAGE ScopedTypeVariables #-}</span>

f ::
  <span class="fragment">forall a.</span>
  [a] -> [a]
f xs =
  ys ++ ys
  where
    ys :: [a]
    ys = reverse xs
</code></pre>
</section><section id="generalisednewtypederiving" class="slide level2">
<h2><code>GeneralisedNewtypeDeriving</code></h2>
<div class="left">
<p>Derive instances for <code>newtype</code>s based on the type they wrap.</p>
</div>
</section><section id="section-24" class="slide level2">
<h2></h2>
<pre><code class="haskell" data-trim data-noescape>
class Pretty a where
  pretty :: a -> Text

<span class="fragment">instance Pretty Int where
  pretty = pack . show</span>

<span class="fragment">newtype Age = Age Int</span>
  <span class="fragment">deriving (Show, Pretty)</span>
</code></pre>
<aside class="notes">
<p><code>newtypes</code> allow the type system to differentiate values that have the same machine representation.</p>
</aside>
</section><section id="section-25" class="slide level2">
<h2></h2>
<pre><code class="nohighlight" data-trim data-noescape>
Can't make a derived instance of ‘Pretty Age’:
  ‘Pretty’ is not a stock derivable class (Eq, Show, etc.)
  Try GeneralizedNewtypeDeriving for GHC's newtype-deriving extension
</code></pre>
</section><section id="section-26" class="slide level2">
<h2></h2>
<pre><code class="haskell" data-trim data-noescape>
class Coercible a b

<span class="fragment">coerce :: Coercible a b => a -> b</span>
</code></pre>
<aside class="notes">
<ul>
<li>Coercible instances tell the type checker that two types have the same representation.
<ul>
<li>same bit pattern in memory</li>
</ul></li>
<li>Programmers cannot create instances of <code>Coercible</code>.</li>
<li>This is just a view that is familiar to programmers.</li>
</ul>
</aside>
</section><section id="section-27" class="slide level2">
<h2></h2>
<pre><code class="haskell" data-trim data-noescape>
<span class="fragment"><mark>{-# LANGUAGE GeneralisedNewtypeDeriving #-}</mark></span>

instance Pretty Int where
  pretty = pack . show

newtype Age = Age Int
  deriving (Show, Pretty)
  
<span class="fragment">instance Coercible Int Age
instance Coercible Age Int</span>

<span class="fragment">instance Pretty Age where
  pretty = coerce $ pack . show</span>
  
<span class="fragment">instance Coercible a b => Coercible (a -> c) (b -> c)</span>
</code></pre>
</section><section id="roles" class="slide level2">
<h2>Roles</h2>
<div class="left">
<p><span class="fragment"><code>GeneralisedNewtypeDeriving</code> as it was originally implemented had some issues that resulted in <strong>roles</strong> being added to the language.</span></p>
<p><span class="fragment">As a result of the role system, adding <code>join</code> to the <code>Monad</code> class would stop <code>GeneralisedNewtypeDeriving</code> from being able to derive <code>Monad</code>.</p>
</div>
<aside class="notes">
<p>Ryan Scott has a great post outlining this. Go look it up if you’re interested.</p>
</aside>
<!-- ## -->
<!-- :::{.left} -->
<!-- Roles determine which notion of equality is used to check if types are equal. -->
<!-- <span class="fragment">Parameters to type level functions are given roles depending on how they are used</span> -->
<!-- - nominal --- `a ~ b` -->
<!-- - representational --- `Coercible a b` -->
<!-- - phantom -->
<!-- ::: -->
<!-- ::: {.notes} -->
<!--  - Before roles, newtypes could cause seg faults in some special circumstances. -->
<!--     + Mixing nominal and representational equality to convince GHC that two types had representational equality when they didn't. -->
<!--  - Example before, we talked about the type system differentiating between things with the same representation. -->
<!--  - Hinting at different notions of equality. -->
<!-- ::: -->
<!-- ::: {.notes} -->
<!-- By "type level functions" I mean things that act like functions: data types, classes, synonyms, type families etc. -->
<!-- ::: -->
<!-- ## Nominal equality -->
<!-- ::: {.left} -->
<!-- Two types are nominally equal if they are the same type. -->
<!-- <span class="fragment">The `~` type operator denotes nominal equality.</span> -->
<!-- ::: -->
<!-- <pre><code class="haskell" data-trim data-noescape> -->
<!-- <span class="fragment">Int ~ Int</span> -->
<!-- <span class="fragment">Maybe Text ~ Maybe Text</span> -->
<!-- <span class="fragment">forall a. [a] ~ [a]</span> -->
<!-- </code></pre> -->
<!-- ::: {.notes} -->
<!-- - Mostly what we think of when we think about equality of types in Haskell. -->
<!-- - Used by `~` constraint. -->
<!-- ::: -->
<!-- ## -->
<!-- :::{.left} -->
<!-- A parameter is given the nominal role if its name is relevant to determining a type's representation. -->
<!-- ::: -->
<!-- <pre><code class="haskell" data-trim data-noescape> -->
<!-- <span class="fragment">newtype Age = Age Int</span> -->
<!-- <span class="fragment">type family Fam a where -->
<!--   Fam Int = Bool -->
<!--   Fam Age = String</span> -->
<!-- <span class="fragment">data Foo a where -->
<!--   Bar :: Foo Int -->
<!--   Baz :: Foo Age</span> -->
<!-- </code></pre> -->
<!-- ## Representational equality -->
<!-- ::: {.left} -->
<!-- Two types that have the same machine representation are equal. -->
<!-- <span class="fragment">`Coercible` constraint in GHC denotes representational equality.</span> -->
<!-- ::: -->
<!-- <pre><code class="haskell" data-trim data-noescape> -->
<!-- <span class="fragment">newtype Age = Age Int</span> -->
<!-- <span class="fragment">Coercible Age Int -->
<!-- Coercible Int Age</span> -->
<!-- </code></pre> -->
<!-- ## -->
<!-- A parameter is given the representational role if only its representation is relevant to determining a type's representation. -->
<!-- <pre class="fragment"><code class="haskell" data-trim data-noescape> -->
<!-- data Maybe a = -->
<!--   Just a -->
<!--   | Nothing -->
<!-- <span class="fragment">(->) a b</span> -->
<!-- </code></pre> -->
<!-- ## Phantom equality -->
<!-- ::: {.left} -->
<!-- Phantom types have no bearing on a type's representation, so any two types are phantom equal. -->
<!-- ::: -->
<!-- <pre class="fragment"><code class="haskell" data-trim data-noescape> -->
<!-- data Foo a = Foo -->
<!-- <span class="fragment">Coercible (Foo a) (Foo b)</span> -->
<!-- </code></pre> -->
<!-- ::: {.notes} -->
<!-- - Phantom equality is a convenience for talking about representational equality. -->
<!-- - This isn't necessary for type soundness. -->
<!-- ::: -->
<!-- ## The roles that bind us -->
<!-- ## -->
<!-- <pre><code class="haskell" data-trim data-noescape> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="1">newtype IdentityT m a = IdentityT (m a) -->
<!--   deriving (Functor, Applicative, </span><span class="fragment" data-fragment-index="1">Monad</span><span class="fragment fade-in-then-semi-out" data-fragment-index="1">)</span><span class="fragment" data-fragment-index="2"></span> -->
<!-- </code></pre> -->
<!-- ## -->
<!-- <pre><code class="haskell" data-trim data-noescape> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="1">class Applicative m => MonadJoin m where -->
<!--   join :: m (m a) -> m a</span> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="2">newtype IdentityT m a = IdentityT (m a) -->
<!--   deriving (Functor, Applicative, </span><span class="fragment" data-fragment-index="2">MonadJoin</span><span class="fragment fade-in-then-semi-out" data-fragment-index="2">)</span><span class="fragment" data-fragment-index="3"></span> -->
<!-- </code></pre> -->
<!-- ## -->
<!-- ### TODO: highlighting -->
<!-- <pre class="no-highlight"><code data-trim data-noescape> -->
<!--     • Couldn't match representation of type ‘m (IdentityT m a)’ -->
<!--                                with that of ‘m (m a)’ -->
<!--         arising from the coercion of the method ‘join’ -->
<!--           from type ‘forall a. m (m a) -> m a’ -->
<!--             to type ‘forall a. IdentityT m (IdentityT m a) ->  -->
<!-- IdentityT m a’ -->
<!--       NB: We cannot know what roles the parameters to ‘m’ have; -->
<!--         we must assume that the role is nominal -->
<!--     • When deriving the instance for (MonadJoin (IdentityT m)) -->
<!--    | -->
<!-- 43 |   deriving (Functor, Applicative, MonadJoin) -->
<!--    |                                   ^^^^^^^^^ -->
<!-- </code></pre> -->
<!-- ## -->
<!-- <pre><code class="haskell" data-trim data-noescape> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="1">instance MonadJoin m => MonadJoin (IdentityT m) where -->
<!--   join :: IdentityT m (IdentityT m a) -> IdentityT m a -->
<!--   join = </span><span class="fragment" data-fragment-index="1">coerce</span> <span class="fragment fade-in-then-semi-out" data-fragment-index="1">(join :: m (m a) -> m a)</span><span class="fragment" data-fragment-index="2"></span> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="3">coerce :: -->
<!--   Coercible (m (m a) -> m a) (IdentityT m (IdentityT m a) -> IdentityT m a) -->
<!--   => (m (m a) -> m a) -->
<!--   -> (IdentityT m (IdentityT m a) -> IdentityT m a)</span> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="4">Coercible (m (m a)) (IdentityT m (IdentityT m a))</span> -->
<!-- <span class="fragment fade-out no-layout" data-fragment-index="6"><span class="fragment no-layout" data-fragment-index="5">Coercible (m (m a)) (m (IdentityT m a))</span></span><span class="fragment no-layout strikethrough" data-fragment-index="6">Coercible (m (m a)) (m (IdentityT m a))</span> -->
<!-- </code></pre> -->
<!-- ::: {.notes} -->
<!-- `m` is unconstrained and could be a type family or something such that its parameters must be -->
<!-- nominally equal for equality to hold. -->
<!-- SIDE NOTE: quantified constraints allow us to constrain instances such that `m` has to have representational -->
<!-- type parameters. -->
<!-- ::: -->
</section></section>
<section><section id="type-classes" class="title-slide slide level1"><h1>Type Classes</h1></section><section id="type-classes-in-haskell-2010" class="slide level2">
<h2>Type classes in Haskell 2010</h2>
<div class="left">
<div class="fragment" data-fragment-index="1">
<p><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3">Section 4.3.1 of the standard</a> covers type classes.</p>
</div>
<div class="fragment" data-fragment-index="2">
<p>To summarise, it says that a type class declaration must have the following form.</p>
</div>
</div>
<pre class="nohighlight fragment" style="font-size: 1.1em" data-fragment-index="3"><code data-trim data-noescape>
<span class="fragment highlight-current-green" data-fragment-index="4">class</span> <span class="fragment highlight-current-green" data-fragment-index="5">cx =></span> <span class="fragment highlight-current-green" data-fragment-index="6">C</span> <span class="fragment highlight-current-green" data-fragment-index="7">u</span> <span class="fragment highlight-current-green" data-fragment-index="8">where cdecls</span>
</code></pre>
<div class="left">
<ul>
<span class="fragment highlight-current-green" data-fragment-index="4"><span class="fragment" data-fragment-index="4">
<li>
<em>must</em> have the <code>class</code> keyword;
</li>
</span></span> <span class="fragment highlight-current-green" data-fragment-index="5"><span class="fragment" data-fragment-index="5">
<li>
<em>may</em> have a context;
</li>
</span></span> <span class="fragment highlight-current-green" data-fragment-index="6"><span class="fragment" data-fragment-index="6">
<li>
<em>must</em> have a class name;
</li>
</span></span> <span class="fragment highlight-current-green" data-fragment-index="7"><span class="fragment" data-fragment-index="7">
<li>
<em>must</em> be parameterised over exactly one type; and
</li>
</span></span> <span class="fragment highlight-current-green" data-fragment-index="8"><span class="fragment" data-fragment-index="8">
<li>
<em>may</em> declare one or more members.
</li>
</span></span>
</ul>
</div>
<aside class="notes">
<ul>
<li>Context specifies superclasses.</li>
<li>Context can only mention the class variable.</li>
</ul>
</aside>
</section><section id="section-28" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
<span class="fragment fade-semi-out" data-fragment-index="1">class Show a where
  show :: a -> String
  ...</span>

<span class="fragment fade-in-then-semi-out" data-fragment-index="1">class Eq a => Ord a where
  compare :: a -> a -> Ordering
  ...</span>

<span class="fragment fade-in-then-semi-out" data-fragment-index="2">class (Ord a, Show a) => ShOrd a</span>
</code></pre>
<aside class="notes">
<p><code>ShOrd</code> doesn’t have a body, but is useful to express a set of constraints using one constraint.</p>
</aside>
</section><section id="type-class-instances-in-haskell-2010" class="slide level2">
<h2>Type class instances in Haskell 2010</h2>
<div class="left">
<div class="fragment" data-fragment-index="1">
<p><a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3">Section 4.3.2 of the standard</a> covers type class instance declarations.</p>
</div>
<div class="fragment" data-fragment-index="2">
<p>In short, it says that a type class instance must have the following form.</p>
</div>
</div>
<pre class="fragment no-highlight" style="font-size: 1em" data-fragment-index="3"><code data-trim data-noescape>
<span class="fragment highlight-current-green" data-fragment-index="4">instance</span> <span class="fragment highlight-current-green" data-fragment-index="5">cx =></span> <span class="fragment highlight-current-green" data-fragment-index="6">C</span> <span class="fragment highlight-current-green" data-fragment-index="7">(T u1 … uk)</span> <span class="fragment highlight-current-green" data-fragment-index="8">where { d }</span>
</code></pre>
<div class="left">
<ul>
<span class="fragment" data-fragment-index="4"><span class="fragment highlight-current-green" data-fragment-index="4">
<li>
<em>must</em> start with the <code>instance</code> keyword;
</li>
</span></span> <span class="fragment" data-fragment-index="5"><span class="fragment highlight-current-green" data-fragment-index="5">
<li>
<em>may</em> have a context;
</li>
</span></span> <span class="fragment" data-fragment-index="6"><span class="fragment highlight-current-green" data-fragment-index="6">
<li>
<em>must</em> mention the class name;
</li>
</span></span> <span class="fragment" data-fragment-index="7"><span class="fragment highlight-current-green" data-fragment-index="7">
<li>
<em>must</em> mention the type the instance is for; and
</li>
</span></span> <span class="fragment" data-fragment-index="8"><span class="fragment highlight-current-green" data-fragment-index="8">
<li>
<em>may</em> contain definitions for the class’s members.
</li>
</span></span>
</ul>
</div>
</section><section id="multiparamtypeclasses" class="slide level2">
<h2><code>MultiParamTypeClasses</code></h2>
<div class="left">
<p>Allows type classes with more than one type parameter.</p>
</div>
</section><section id="section-29" class="slide level2">
<h2></h2>
<pre class="haskell"><code>class Monad m =&gt; MonadReader r m where
  ask :: m r
  ...</code></pre>
<aside class="notes">
<ul>
<li><code>MonadReader</code> is a common class from the <code>mtl</code> package.</li>
<li>Allows us to avoid concrete transformer stacks throughout much of our code.</li>
<li>Class is not permitted by Haskell 2010</li>
</ul>
</aside>
</section><section id="flexibleinstances" class="slide level2">
<h2><code>FlexibleInstances</code></h2>
<div class="left">
<p>Relaxes the rules for valid type class instances.</p>
</div>
</section><section id="section-30" class="slide level2">
<h2></h2>
<ul>
<li class="fragment">Instance types can be type variables.</li>
<li class="fragment">Type variables can appear multiple times in the instance head.</li>
<li class="fragment">Concrete types may be used as parameters to instance types.</li>
</ul>
</section><section id="section-31" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
<span class="fragment fade-semi-out" data-fragment-index="1">class Monad m => MonadReader r m where
  ask :: m r</span>

<span class="fragment" data-fragment-index="1">instance MonadReader r ((->) r) where
  ask = id
</code></pre>
</section><section id="section-32" class="slide level2">
<h2></h2>
<pre class="no-highlight"><code data-trim data-noescape>
<span class="fragment fade-semi-out" data-fragment-index="1">type-class-extensions.lhs:123:10-32: error:
    • Illegal instance declaration for ‘MonadReader r ((->) r)’</span>
        <span class="fragment highlight-current-green" data-fragment-index="1">(All instance types must be of the form (T a1 ... an)
         where a1 ... an are *distinct type variables*</span><span class="fragment fade-semi-out" data-fragment-index="1">,
         and </span><span class="fragment highlight-current-green" data-fragment-index="2">each type variable appears at most once in the instance head.</span>
         <span class="fragment highlight-current-green" data-fragment-index="3">Use FlexibleInstances if you want to disable this.</span><span class="fragment fade-semi-out" data-fragment-index="1">)
    • In the instance declaration for ‘MonadReader r ((->) r)’
    |
123 | instance MonadReader r ((->) r) where</span>
</code></pre>
<aside class="notes">
<ul>
<li>First parameter not a type constructor.</li>
<li><code>r</code> appears multiple times.</li>
</ul>
</aside>
</section><section id="section-33" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
class Twizzle a where
  twizzle :: a -> Int

instance Twizzle (Maybe Integer) where
  twizzle = maybe 42 fromInteger
</code></pre>
<aside class="notes">
<p><strong>COME UP WITH A BETTER EXAMPLE</strong></p>
<p><code>FlexibleInstances</code> also allows us to write instances for fully concrete types.</p>
</aside>
<!-- ## Not so benign -->
<!-- ::: {.notes} -->
<!-- - Seen some people claim that FlexibleInstances is benign. -->
<!-- - Often is, but it can bite you if you're not careful. -->
<!-- ::: -->
<!-- ## -->
<!-- <pre class="haskell"><code data-trim data-noescape> -->
<!-- module FIA where -->
<!-- data A = A1 | A2 deriving (Eq, Ord, Show) -->
<!-- data Whoopsie a b c = -->
<!--   Whoopsie a b c -->
<!--   deriving (Eq, Show) -->
<!-- </code></pre> -->
<!-- ## -->
<!-- <pre class="haskell"><code data-trim data-noescape> -->
<!-- {-# LANGUAGE FlexibleInstances #-} -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="2">module FIB where -->
<!-- import Data.Set (Set, insert) -->
<!-- import FIA</span> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="3">data B = B deriving (Eq, Ord, Show)</span> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="4">instance Ord c => </span><span class="fragment" data-fragment-index="4">Ord (Whoopsie A B c)</span><span class="fragment fade-in-then-semi-out" data-fragment-index="4"> where -->
<!--   compare (Whoopsie a1 b1 c1) (Whoopsie a2 b2 c2) =</span> -->
<!--     <span class="fragment" data-fragment-index="4">compare a1 a2</span><span class="fragment fade-in-then-semi-out" data-fragment-index="4"> <> compare b1 b2 <> compare c1 c2</span><span class="fragment" data-fragment-index="5"></span> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="6">insB :: Ord c => Whoopsie A B c -> Set (Whoopsie A B c) -> Set (Whoopsie A B c) -->
<!-- insB = insert</span> -->
<!-- </code></pre> -->
<!-- ## -->
<!-- <pre class="haskell"><code data-trim data-noescape> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="1">{-# LANGUAGE FlexibleInstances #-} -->
<!-- module FIC where -->
<!-- import Data.Set (Set, insert) -->
<!-- import FIA -->
<!-- data C = C deriving (Eq, Ord, Show)</span> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="2">instance Ord b => </span><span class="fragment" data-fragment-index="2">Ord (Whoopsie A b C)</span><span class="fragment fade-in-then-semi-out" data-fragment-index="2"> where -->
<!--   compare (Whoopsie a1 b1 c1) (Whoopsie a2 b2 c2) =</span> -->
<!--     <span class="fragment" data-fragment-index="2">compare a2 a1</span><span class="fragment fade-in-then-semi-out" data-fragment-index="2"> <> compare b1 b2 <> compare c1 c2</span><span class="fragment" data-fragment-index="3"></span> -->
<!-- <span class="fragment" data-fragment-index="4">insC :: Ord b => Whoopsie A b C -> Set (Whoopsie A b C) -> Set (Whoopsie A b C) -->
<!-- insC = insert</span> -->
<!-- </code></pre> -->
<!-- ## -->
<!-- <pre class="haskell"><code data-trim data-noescape> -->
<!-- <span class="fragment fade-in-then-semi-out">module Main where -->
<!-- import Data.Set (Set, empty) -->
<!-- import FIA -->
<!-- import FIB -->
<!-- import FIC -->
<!-- test :: Set (Whoopsie A B C) -->
<!-- test =</span> -->
<!--   <span class="fragment">insB (Whoopsie A1 B C) . </span><span class="fragment">insC (Whoopsie A1 B C) . </span><span class="fragment">insC (Whoopsie A2 B C) $ empty</span> -->
<!-- <span class="fragment">main :: IO () -->
<!-- main = -->
<!--   print test</span> -->
<!-- </code></pre> -->
</section><section id="section-34" class="slide level2">
<h2></h2>
<pre class="no-highlight"><code data-trim data-noescape>
<span class="fragment fade-semi-out" data-fragment-index="1">$ ghc --version
The Glorious Glasgow Haskell Compilation System, version 8.4.4</span>

<span class="fragment fade-in-then-semi-out" data-fragment-index="1">$ ghc -Wall -fforce-recomp Main.hs -o whoopsie</span>
<span class="fragment fade-in-then-semi-out" data-fragment-index="2">[1 of 4] Compiling FIA              ( FIA.hs, FIA.o )
[2 of 4] Compiling FIB              ( FIB.hs, FIB.o )
[3 of 4] Compiling FIC              ( FIC.hs, FIC.o )
[4 of 4] Compiling Main             ( Main.hs, Main.o )
Linking whoopsie ...</span>

<span class="fragment fade-in-then-semi-out" data-fragment-index="3">> ./whoopsie
fromList [</span><span class="fragment" data-fragment-index="3">Whoopsie A1 B C</span><span class="fragment fade-in-then-semi-out" data-fragment-index="3">,Whoopsie A2 B C,</span><span class="fragment" data-fragment-index="3">Whoopsie A1 B C</span><span class="fragment fade-in-then-semi-out" data-fragment-index="3">]</span><span class="fragment" data-fragment-index="5"></span>
</code></pre>
</section><section id="flexiblecontexts" class="slide level2">
<h2><code>FlexibleContexts</code></h2>
<div class="left">
<p>Relax some of the requirements regarding contexts.</p>
</div>
</section><section id="section-35" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
updateThing ::
  MonadState MyState m
  => m ()
</code></pre>
<aside class="notes">
<ul>
<li>Requires FlexibleContexts because of the non type-variable argument to <code>MonadState</code></li>
<li>Fairly common to specify concrete type for environment/state.</li>
</ul>
</aside>
</section><section id="section-36" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
updateThing ::
  ( HasThing s
  , MonadState s m
  )
  => m ()
</code></pre>
<aside class="notes">
<p>Counterpoint is that often this isn’t necessary and we can add constraints, remain polymorphic, and maximise reuse.</p>
</aside>
</section><section id="functionaldependencies" class="slide level2">
<h2><code>FunctionalDependencies</code></h2>
<div class="left">
<p>Express dependent relationships between type variables for type classes with multiple parameters.</p>
</div>
</section><section id="section-37" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
<span class="fragment fade-semi-out" data-fragment-index="1">{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}

class Monad m => MonadReader r m where
  ask :: m r</span>

<span class="fragment fade-in-then-semi-out" data-fragment-index="1">instance MonadReader r ((->) r) where
  ask = id</span>

<span class="fragment" data-fragment-index="2">foo ::
  Integer
foo =
  (+ 1) <$> ask $ 41</span>
</code></pre>
<aside class="notes">
<ul>
<li>Refresh memory after diversion.</li>
<li>MPTC to declare our class.</li>
<li><code>FlexibleInstances</code> to define an instance for the function type.</li>
</ul>
</aside>
</section><section id="section-38" class="slide level2">
<h2></h2>
<pre class="no-highlight"><code data-trim data-noescape>
<span class="fragment fade-semi-out" data-fragment-index="1">type-class-extensions.lhs:275:13-16: error:
    • </span>Ambiguous type variable ‘t0’ arising from a use of ‘ask’
      prevents the constraint ‘(MonadReader
                                  Integer ((->) t0))’ from being solved.
      <span class="fragment fade-semi-out" data-fragment-index="1">Probable fix: use a type annotation to specify what ‘t0’ should be.
      These potential instance exist:
        one instance involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In the second argument of ‘(<$>)’, namely ‘ask’
      In the expression: (+ 1) <$> ask
      In the expression: (+ 1) <$> ask $ 100</span>
    |
275 |   (+ 1) <$> ask $ 41
    |             ^^^
</code></pre>
<aside class="notes">
<ul>
<li>Intuition might say that 100 must be an Integer — only one instance of MonadReader.</li>
<li>To make it clearer, what if I defined a new instance.</li>
</ul>
</aside>
<!-- ## -->
<!-- <pre class="haskell"><code data-trim data-noescape> -->
<!-- <span class="fragment fade-in-then-semi-out">{-# LANGUAGE FlexibleInstances #-} -->
<!-- {-# LANGUAGE GeneralisedNewtypeDeriving #-} -->
<!-- {-# LANGUAGE MultiParamTypeClasses #-} -->
<!-- module FunDeps where</span> -->
<!-- <span class="fragment fade-in-then-semi-out">class Monad m => MonadReader r m where -->
<!--   ask :: m r -->
<!-- instance MonadReader r ((->) r) where -->
<!--   ask = id</span> -->
<!-- <span class="fragment fade-in-then-semi-out">newtype Sinteger = Sinteger Integer -->
<!--   deriving (Eq, Show, Num, Ord, Real, Enum, Integral)</span> -->
<!-- <span class="fragment fade-in-then-semi-out">instance MonadReader Integer ((->) Sinteger) where -->
<!--   ask (Sinteger n) = n + 1</span> -->
<!-- <span class="fragment">foo :: -->
<!--   Integer -->
<!-- foo = -->
<!--   (+ 1) <$> ask $ 41</span> -->
<!-- </code></pre> -->
<!-- ## -->
<!-- <pre class="haskell"><code data-trim data-noescape> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="1">{-# LANGUAGE FunctionalDependencies #-}</span> -->
<!-- <span class="fragment fade-in-then-semi-out" data-fragment-index="2">class Monad m => MonadReader r m </span><span class="fragment" data-fragment-index="2">| m -> r </span><span class="fragment fade-in-then-semi-out" data-fragment-index="2">where -->
<!--   ask :: m r</span></span><span class="fragment" data-fragment-index="3"></span> -->
<!-- <span class="fragment" data-fragment-index="4">instance MonadReader r ((->) r) where -->
<!--   ask = id</span> -->
<!-- <span class="fragment" data-fragment-index="5">instance MonadReader Integer ((->) Sinteger) where -->
<!--   ask (Sinteger n) = n + 1</span> -->
<!-- </code></pre> -->
<!-- ## -->
<!-- <pre class="no-highlight"><code data-trim data-noescape> -->
<!-- FunDeps.hs:14:10: error: -->
<!--     <span style="color: red">Functional dependencies conflict between instance declarations: -->
<!--       instance MonadReader r ((->) r) -- Defined at FunDeps.hs:14:10 -->
<!--       instance MonadReader Integer ((->) Sinteger)</span> -->
<!--         -- Defined at FunDeps.hs:20:10 -->
<!--    | -->
<!-- 14 | instance MonadReader r ((->) r) where -->
<!--    |          ^^^^^^^^^^^^^^^^^^^^^^ -->
<!-- </code></pre> -->
</section><section id="section-39" class="slide level2">
<h2></h2>
<pre class="haskell"><code data-trim data-noescape>
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
<mark>{-# LANGUAGE FunctionalDependencies #-}</mark>

<span class="fragment fade-in-then-semi-out" data-fragment-index="1">class Monad m => MonadReader r m</span> <span class="fragment" data-fragment-index="1">| m -> r </span><span class="fragment fade-in-then-semi-out" data-fragment-index="1">where
  ask :: m r</span><span class="fragment" data-fragment-index="2"></span>

<span class="fragment fade-in-then-semi-out" data-fragment-index="3">instance MonadReader r ((->) r) where
  ask = id</span>

<span class="fragment fade-in-then-semi-out" data-fragment-index="4">foo ::
  Integer
foo =
  (+ 1) <$> ask $ 41</span>
</code></pre>
</section></section>
<section><section id="conclusion" class="title-slide slide level1"><h1>Conclusion</h1></section><section id="section-40" class="slide level2">
<h2></h2>
<ul>
<li class="fragment">Haskell 2010 is smaller than you think.</li>
<li class="fragment">GHC defines many extensions to the language.</li>
<li class="fragment">Language extensions come with tradeoffs.</li>
</ul>
</section></section>
<section><section id="references" class="title-slide slide level1"><h1>References</h1></section><section id="section-41" class="slide level2">
<h2></h2>
<div class="left">
<p><strong>GHC language extensions</strong><br />
<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html">https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html</a></p>
<p><strong>Haskell 2010 report</strong><br />
<a href="https://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-19100012.3">https://www.haskell.org/onlinereport/haskell2010/haskellch12.html#x19-19100012.3</a></p>
<p><strong>24 Days of GHC extensions</strong><br />
<a href="https://ocharles.org.uk/pages/2014-12-01-24-days-of-ghc-extensions.html">https://ocharles.org.uk/pages/2014-12-01-24-days-of-ghc-extensions.html</a></p>
<p><strong>Putting <code>join</code> in <code>Monad</code></strong><br />
<a href="https://ryanglscott.github.io/2018/03/04/how-quantifiedconstraints-can-let-us-put-join-back-in-monad/">https://ryanglscott.github.io/2018/03/04/how-quantifiedconstraints-can-let-us-put-join-back-in-monad/</a></p>
<p><strong><code>FlexibleInstances</code> breaking <code>Data.Set</code></strong><br />
<a href="https://gist.github.com/rwbarton/dd8e51dce2a262d17a80">https://gist.github.com/rwbarton/dd8e51dce2a262d17a80</a></p>
</div>
</section><section id="images" class="slide level2">
<h2>Images</h2>
<div class="left">
<p><strong>Muhammad Ali</strong><br />
<a href="https://commons.wikimedia.org/wiki/File:Muhammad_Ali_1966.jpg">https://commons.wikimedia.org/wiki/File:Muhammad_Ali_1966.jpg</a></p>
<p><strong>Records</strong><br />
<a href="https://flic.kr/p/8fsrnG">https://flic.kr/p/8fsrnG</a></p>
</div>
</section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom
        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1300,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
              { src: 'reveal.js/plugin/notes/notes.js', async: true },
		      { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
    </body>
</html>
